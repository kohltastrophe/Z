--!optimize 2
--!native
--!strict

-- Documentation: github.com/kohltastrophe/Z
-- High-performance, schematized buffer serialization for Roblox Luau

local MB = 1024 ^ 2
local BUFFER = buffer.create(MB)

local SIZE_8 = 2 ^ 8 - 1
local SIZE_16 = 2 ^ 16 - 1
local SIZE_32 = 2 ^ 32 - 1
export type Read = (b: buffer, offset: number) -> (any, number)
export type Write = (b: buffer, offset: number, value: any) -> number
export type ZType = { read: Read, write: Write }

export type Data = { [number | string | ZType]: any }
export type SchemaDefinition = { [number | string | ZType]: ZType }

export type Field = { key: number | string | ZType, read: Read, write: Write, type: string }
export type Schema = {
	fields: { Field },
	isList: boolean,
	isMap: boolean,
	name: string,
	deserialize: (schema: Schema, b: buffer, offset: number?, safe: boolean?) -> (Data, number),
	serializeUnsafe: (schema: Schema, obj: Data, b: buffer?, offset: number?) -> number,
	read: Read,
	write: Write,
	readLen: (b: buffer, offset: number) -> any,
	writeLen: (b: buffer, offset: number, value: number) -> (),
	sizeLen: number,
}

local function isZType(value: any?): boolean
	return type(value) == "table" and type(value.read) == "function" and type(value.write) == "function"
end

local Z = {
	BUFFER = BUFFER,
	TRIM_STRINGS = false,
}

local zBitLengthCache: { [number]: (definition: SchemaDefinition) -> Schema } = {}

local function deserializeZType(t: ZType, b: buffer, offset: number?, safe: boolean?): (any, number)
	if safe then
		local ok, result, nextOffset = pcall(t.read :: any, b, offset or 0)
		if not ok then
			return nil, nextOffset
		end
		return result, nextOffset
	else
		return t.read(b, offset or 0)
	end
end

local metaZ = {
	__newindex = function(_, key, value)
		if isZType(value) then
			if not value.name then
				(value :: any).name = key
			end
			if not value.deserialize then
				(value :: any).deserialize = deserializeZType
			end
			pcall(table.freeze, value :: any)
		end
		rawset(Z :: any, key, value)
	end,
	__call = function(_, param: any): any
		if type(param) == "number" then
			if param ~= 8 and param ~= 16 and param ~= 32 then
				error(`Expected 8, 16, or 32 for parameter "bits", got {param}`)
			end
			if not zBitLengthCache[param] then
				zBitLengthCache[param] = function(definition: SchemaDefinition)
					return (Z :: any).schema(definition, param) :: Schema
				end
			end
			return zBitLengthCache[param]
		end
		return (Z :: any).schema(param)
	end,
}

setmetatable(Z, metaZ)

local someCache = {}

--- Wraps a ZType to make it optional, adding 1 byte of overhead.
function Z.some(t: ZType): ZType
	local result = someCache[t]

	if not result then
		local read, write = t.read, t.write
		result = table.freeze({
			name = `some({(t :: any).name})`,
			deserialize = deserializeZType,
			write = function(b: buffer, offset: number, value: any): number
				if value ~= nil then
					buffer.writeu8(b, offset, 1)
					return write(b, offset + 1, value)
				else
					buffer.writeu8(b, offset, 0)
					return offset + 1
				end
			end,
			read = function(b: buffer, offset: number, safe: boolean?): (any, number)
				if buffer.readu8(b, offset) == 1 then
					return (read :: any)(b, offset + 1, safe)
				else
					return nil, offset + 1
				end
			end,
		}) :: any
		someCache[t] = result
	end

	return result
end

--stylua: ignore
local function writeu8x4(b: buffer, offset: number, w: number, x: number?, y: number?, z: number?)
	buffer.writeu32(b, offset, math.round(w) + math.round(x or 0) * 2 ^ 8 + math.round(y or 0) * 2 ^ 16 + math.round(z or 0) * 2 ^ 24)
end

type B = boolean

local function readBool(b: buffer, offset: number): (B, B, B, B, B, B, B, B)
	local x = buffer.readu8(b, offset)
	return x % 2 == 1, x % 4 >= 2, x % 8 >= 4, x % 16 >= 8, x % 32 >= 16, x % 64 >= 32, x % 128 >= 64, x % 256 >= 128
end

local function writeBool(buf: buffer, offset: number, a: B, b: B?, c: B?, d: B?, e: B?, f: B?, g: B?, h: B?)
	local byte = if a then 1 else 0
	if b then
		byte += 2
	end
	if c then
		byte += 4
	end
	if d then
		byte += 8
	end
	if e then
		byte += 16
	end
	if f then
		byte += 32
	end
	if g then
		byte += 64
	end
	if h then
		byte += 128
	end
	buffer.writeu8(buf, offset, byte)
	return offset + 1
end

local boolArrayCache: { [number]: ZType } = {}

Z.bool = setmetatable({
	read = function(b: buffer, offset: number): (boolean, number)
		return buffer.readu8(b, offset) == 1, offset + 1
	end,
	write = function(b: buffer, offset: number, value: boolean): number
		if type(value) ~= "boolean" then
			error(`boolean expected, got {typeof(value)}`)
		end
		buffer.writeu8(b, offset, if value then 1 else 0)
		return offset + 1
	end,
}, {
	__call = function(_, n: number): ZType
		if n < 1 then
			error(`bool(n) must be positive, got {n}`)
		end

		if boolArrayCache[n] then
			return boolArrayCache[n]
		end

		local numBytes = math.ceil(n / 8)

		boolArrayCache[n] = table.freeze({
			name = `bool({n})`,
			deserialize = deserializeZType,
			write = function(b: buffer, offset: number, v: { boolean }): number
				for i = 0, (numBytes - 1) * 8, 8 do
					writeBool(b, offset, v[i + 1], v[i + 2], v[i + 3], v[i + 4], v[i + 5], v[i + 6], v[i + 7], v[i + 8])
				end
				return offset + numBytes
			end,
			read = function(b: buffer, offset: number): ({ boolean }, number)
				local v: { boolean } = {}
				for i = 0, numBytes - 1 do
					local j = i * 8
					v[j + 1], v[j + 2], v[j + 3], v[j + 4], v[j + 5], v[j + 6], v[j + 7], v[j + 8] =
						readBool(b, offset + i)
				end
				return v, offset + numBytes
			end,
		}) :: any

		return boolArrayCache[n]
	end,
})

Z.boolean = Z.bool

Z.u8 = {
	read = function(b: buffer, offset: number): (number, number)
		return buffer.readu8(b, offset), offset + 1
	end,
	write = function(b: buffer, offset: number, value: number): number
		buffer.writeu8(b, offset, value)
		return offset + 1
	end,
}

Z.u16 = {
	read = function(b: buffer, offset: number): (number, number)
		return buffer.readu16(b, offset), offset + 2
	end,
	write = function(b: buffer, offset: number, value: number): number
		buffer.writeu16(b, offset, value)
		return offset + 2
	end,
}

Z.u32 = {
	read = function(b: buffer, offset: number): (number, number)
		return buffer.readu32(b, offset), offset + 4
	end,
	write = function(b: buffer, offset: number, value: number): number
		buffer.writeu32(b, offset, value)
		return offset + 4
	end,
}

Z.uint = {
	read = function(b: buffer, offset: number?): (number, number)
		local buffLen = buffer.len(b)
		local readOffset = offset or 0
		local result, shift = 0, 0
		while true do
			if readOffset >= buffLen then
				error("ULEB128Decode: malformed sequence, buffer underflow")
			end
			local byte = buffer.readu8(b, readOffset)
			local sevenBits = byte % 128
			if shift == 49 and (sevenBits > 16 or result > 0) then
				error("ULEB128Decode: integer exceeds 53-bit precision")
			end
			readOffset += 1
			result += (sevenBits * (2 ^ shift))
			if byte < 128 then
				break
			end
			shift += 7
			if shift > 49 then
				error("ULEB128Decode: integer exceeds 53-bit precision or is malformed")
			end
		end
		return result, readOffset
	end,
	write = function(b: buffer, offset: number, value: number): number
		value = math.min(math.floor(value), 2 ^ 53)
		if value < 0 then
			error(`ULEB128Encode: "value" must be non-negative, got {value}`)
		end
		if value == 0 then
			buffer.writeu8(b, offset, 0)
			return offset + 1
		end
		while value > 0 do
			local byte = value % 128
			value //= 128
			if value > 0 then
				byte += 128
			end
			buffer.writeu8(b, offset, byte)
			offset += 1
		end
		return offset
	end,
}

Z.i8 = {
	read = function(b: buffer, offset: number): (number, number)
		return buffer.readi8(b, offset), offset + 1
	end,
	write = function(b: buffer, offset: number, value: number): number
		buffer.writei8(b, offset, value)
		return offset + 1
	end,
}

Z.i16 = {
	read = function(b: buffer, offset: number): (number, number)
		return buffer.readi16(b, offset), offset + 2
	end,
	write = function(b: buffer, offset: number, value: number): number
		buffer.writei16(b, offset, value)
		return offset + 2
	end,
}

Z.i32 = {
	read = function(b: buffer, offset: number): (number, number)
		return buffer.readi32(b, offset), offset + 4
	end,
	write = function(b: buffer, offset: number, value: number): number
		buffer.writei32(b, offset, value)
		return offset + 4
	end,
}

Z.int = {
	read = function(b: buffer, offset: number?): (number, number)
		local buffLen = buffer.len(b)
		local readOffset = offset or 0
		if readOffset >= buffLen then
			error("SLEB128Decode: malformed sequence, buffer underflow (reading first byte)")
		end
		local firstByte = buffer.readu8(b, readOffset)
		readOffset += 1
		local signBit = (firstByte % 128) // 64
		local magnitude = firstByte % 64
		if firstByte < 128 then
			return (if signBit == 1 then -magnitude else magnitude), readOffset
		end
		local shift = 6
		while true do
			if readOffset >= buffLen then
				error("SLEB128Decode: malformed sequence, buffer underflow (reading continuation byte)")
			end
			local byte = buffer.readu8(b, readOffset)
			readOffset += 1
			local sevenBits = byte % 128
			magnitude += (sevenBits * (2 ^ shift))
			if byte < 128 then
				break
			end
			shift += 7
			if shift > 48 then
				error("SLEB128Decode: integer exceeds 53-bit precision or is malformed")
			end
		end
		return (if signBit == 1 then -magnitude else magnitude), readOffset
	end,
	write = function(b: buffer, offset: number, value: number): number
		value = math.clamp(math.round(value), -2 ^ 53, 2 ^ 53)
		local signBit: number
		local magnitude: number
		if value < 0 then
			signBit = 1
			magnitude = -value
		else
			signBit = 0
			magnitude = value
		end
		if magnitude == 0 then
			buffer.writeu8(b, offset, 0)
			return offset + 1
		end
		local firstSixBits = magnitude % 64
		magnitude //= 64
		local byte = firstSixBits + (signBit * 64)
		if magnitude > 0 then
			byte += 128
		end
		buffer.writeu8(b, offset, byte)
		offset += 1
		while magnitude > 0 do
			byte = magnitude % 128
			magnitude //= 128
			if magnitude > 0 then
				byte += 128
			end
			buffer.writeu8(b, offset, byte)
			offset += 1
		end
		return offset
	end,
}

Z.f32 = {
	read = function(b: buffer, offset: number): (number, number)
		return buffer.readf32(b, offset), offset + 4
	end,
	write = function(b: buffer, offset: number, value: number): number
		buffer.writef32(b, offset, value)
		return offset + 4
	end,
}

Z.f64 = {
	read = function(b: buffer, offset: number): (number, number)
		return buffer.readf64(b, offset), offset + 8
	end,
	write = function(b: buffer, offset: number, value: number): number
		buffer.writef64(b, offset, value)
		return offset + 8
	end,
}

Z.number = Z.f64

Z.byte = {
	read = function(b: buffer, offset: number): (string, number)
		return buffer.readstring(b, offset, 1), offset + 1
	end,
	write = function(b: buffer, offset: number, value: string): number
		buffer.writestring(b, offset, value, 1)
		return offset + 1
	end,
}

local function createStringType(
	size: number,
	readLen: (b: buffer, offset: number) -> number,
	writeLen: (b: buffer, offset: number, value: number) -> (),
	lenBytes: number
)
	return {
		read = function(b: buffer, offset: number): (string, number)
			local length = readLen(b, offset)
			return buffer.readstring(b, offset + lenBytes, length), offset + lenBytes + length
		end,
		write = function(b: buffer, offset: number, value: string): number
			local length = string.len(value)
			if length > size and not Z.TRIM_STRINGS then
				error(`string exceeds bounds`)
			end
			writeLen(b, offset, math.min(length, size))
			buffer.writestring(b, offset + lenBytes, value, math.min(length, size))
			return offset + lenBytes + length
		end,
	}
end

Z.str8 = createStringType(SIZE_8, buffer.readu8, buffer.writeu8, 1)
Z.str16 = createStringType(SIZE_16, buffer.readu16, buffer.writeu16, 2)
Z.str32 = createStringType(SIZE_32, buffer.readu32, buffer.writeu32, 4)
Z.string = Z.str32

local function createBufferType(
	size: number,
	readLen: (b: buffer, offset: number) -> number,
	writeLen: (b: buffer, offset: number, value: number) -> (),
	lenBytes: number
)
	return {
		read = function(b: buffer, offset: number): (buffer, number)
			local length = readLen(b, offset)
			local value = buffer.create(length)
			buffer.copy(value, 0, b, offset + lenBytes, length)
			return value, offset + lenBytes + length
		end,
		write = function(b: buffer, offset: number, value: buffer): number
			local length = buffer.len(value)
			if length > size then
				error(`buffer exceeds bounds`)
			end
			writeLen(b, offset, length)
			buffer.copy(b, offset + lenBytes, value)
			return offset + lenBytes + length
		end,
	}
end

Z.buffer8 = createBufferType(SIZE_8, buffer.readu8, buffer.writeu8, 1)
Z.buffer16 = createBufferType(SIZE_16, buffer.readu16, buffer.writeu16, 2)
Z.buffer32 = createBufferType(SIZE_32, buffer.readu32, buffer.writeu32, 4)
Z.buffer = Z.buffer32

local range = math.rad(359)

local function Angle8(angle: number): number
	return math.round((angle % (2 * math.pi)) * 255 / range)
end

local Angle8Map: { number } = {}

for i = 0, SIZE_8 do
	Angle8Map[i] = i * range / SIZE_8
end

for degrees = 0, 315, 45 do
	local angle = math.rad(degrees)
	Angle8Map[Angle8(angle)] = angle
end

Z.Angle8 = {
	read = function(b: buffer, offset: number): (number, number)
		return Angle8Map[buffer.readu8(b, offset)], offset + 1
	end,
	write = function(b: buffer, offset: number, value: number): number
		buffer.writeu8(b, offset, Angle8(value))
		return offset + 1
	end,
}

if Axes then
	Z.Axes = {
		read = function(b: buffer, offset: number): (Axes, number)
			local x, y, z = readBool(b, offset)
			local back, bottom, front, left, right, top = readBool(b, offset + 1)
			return Axes.new(
				x and Enum.Axis.X :: any,
				y and Enum.Axis.Y :: any,
				z and Enum.Axis.Z :: any,
				back and Enum.NormalId.Back :: any,
				bottom and Enum.NormalId.Bottom :: any,
				front and Enum.NormalId.Front :: any,
				left and Enum.NormalId.Left :: any,
				right and Enum.NormalId.Right :: any,
				top and Enum.NormalId.Top :: any
			),
				offset + 2
		end,
		write = function(b: buffer, offset: number, value: Axes): number
			writeBool(b, offset, value.X, value.Y, value.Z)
			writeBool(b, offset + 1, value.Back, value.Bottom, value.Front, value.Left, value.Right, value.Top)
			return offset + 2
		end,
	}
end

if BrickColor then
	Z.BrickColor = {
		read = function(b: buffer, offset: number): (BrickColor, number)
			return BrickColor.new(buffer.readu16(b, offset)), offset + 2
		end,
		write = function(b: buffer, offset: number, value: BrickColor): number
			buffer.writeu16(b, offset, value.Number)
			return offset + 2
		end,
	}
end

if CFrame then
	Z.CFrame = {
		read = function(b: buffer, offset: number): (CFrame, number)
			return CFrame.new(
				buffer.readf32(b, offset),
				buffer.readf32(b, offset + 4),
				buffer.readf32(b, offset + 8),
				buffer.readf32(b, offset + 12),
				buffer.readf32(b, offset + 16),
				buffer.readf32(b, offset + 20),
				buffer.readf32(b, offset + 24),
				buffer.readf32(b, offset + 28),
				buffer.readf32(b, offset + 32),
				buffer.readf32(b, offset + 36),
				buffer.readf32(b, offset + 40),
				buffer.readf32(b, offset + 44)
			),
				offset + 48
		end,
		write = function(b: buffer, offset: number, value: CFrame): number
			local v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11 = value:GetComponents()
			buffer.writef32(b, offset, v0)
			buffer.writef32(b, offset + 4, v1)
			buffer.writef32(b, offset + 8, v2)
			buffer.writef32(b, offset + 12, v3)
			buffer.writef32(b, offset + 16, v4)
			buffer.writef32(b, offset + 20, v5)
			buffer.writef32(b, offset + 24, v6)
			buffer.writef32(b, offset + 28, v7)
			buffer.writef32(b, offset + 32, v8)
			buffer.writef32(b, offset + 36, v9)
			buffer.writef32(b, offset + 40, v10)
			buffer.writef32(b, offset + 44, v11)
			return offset + 48
		end,
	}

	Z.CFrame28 = {
		read = function(b: buffer, offset: number): (CFrame, number)
			return CFrame.fromAxisAngle(
				Vector3.new(
					buffer.readf32(b, offset + 12),
					buffer.readf32(b, offset + 16),
					buffer.readf32(b, offset + 20)
				),
				buffer.readf32(b, offset + 24)
			) + Vector3.new(buffer.readf32(b, offset), buffer.readf32(b, offset + 4), buffer.readf32(b, offset + 8)),
				offset + 28
		end,
		write = function(b: buffer, offset: number, value: CFrame): number
			local axis, angle = value:ToAxisAngle()
			buffer.writef32(b, offset, value.X)
			buffer.writef32(b, offset + 4, value.Y)
			buffer.writef32(b, offset + 8, value.Z)
			buffer.writef32(b, offset + 12, axis.X)
			buffer.writef32(b, offset + 16, axis.Y)
			buffer.writef32(b, offset + 20, axis.Z)
			buffer.writef32(b, offset + 24, angle)
			return offset + 28
		end,
	}

	Z.CFrame15 = {
		read = function(b: buffer, offset: number): (CFrame, number)
			return CFrame.Angles(
				Angle8Map[buffer.readu8(b, offset + 12)],
				Angle8Map[buffer.readu8(b, offset + 13)],
				Angle8Map[buffer.readu8(b, offset + 14)]
			) + Vector3.new(buffer.readf32(b, offset), buffer.readf32(b, offset + 4), buffer.readf32(b, offset + 8)),
				offset + 15
		end,
		write = function(b: buffer, offset: number, value: CFrame): number
			local rx, ry, rz = value:ToOrientation()
			buffer.writef32(b, offset, value.X)
			buffer.writef32(b, offset + 4, value.Y)
			buffer.writef32(b, offset + 8, value.Z)
			writeu8x4(b, offset + 12, Angle8(rx), Angle8(ry), Angle8(rz))
			return offset + 15
		end,
	}
end

if Color3 then
	Z.Color3 = {
		read = function(b: buffer, offset: number): (Color3, number)
			return Color3.fromRGB(buffer.readu8(b, offset), buffer.readu8(b, offset + 1), buffer.readu8(b, offset + 2)),
				offset + 3
		end,
		write = function(b: buffer, offset: number, value: Color3): number
			writeu8x4(b, offset, value.R * 255, value.G * 255, value.B * 255)
			return offset + 3
		end,
	}
end

if ColorSequenceKeypoint then
	Z.ColorSequenceKeypoint = {
		read = function(b: buffer, offset: number): (ColorSequenceKeypoint, number)
			return ColorSequenceKeypoint.new(
				buffer.readu8(b, offset) / 255,
				Color3.fromRGB(buffer.readu8(b, offset + 1), buffer.readu8(b, offset + 2), buffer.readu8(b, offset + 3))
			),
				offset + 4
		end,
		write = function(b: buffer, offset: number, value: ColorSequenceKeypoint): number
			writeu8x4(b, offset, value.Time * 255, value.Value.R * 255, value.Value.G * 255, value.Value.B * 255)
			return offset + 4
		end,
	}
end

if ColorSequence then
	Z.ColorSequence = {
		read = function(b: buffer, offset: number): (ColorSequence, number)
			local count = buffer.readu8(b, offset)
			local points: { ColorSequenceKeypoint } = {}
			for i = 1, count do
				local point = Z.ColorSequenceKeypoint.read(b, offset + 1 + (i - 1) * 4)
				table.insert(points, point)
			end
			return ColorSequence.new(points), offset + 1 + count * 4
		end,
		write = function(b: buffer, offset: number, value: ColorSequence): number
			local count = #value.Keypoints
			buffer.writeu8(b, offset, count)
			for i, point in value.Keypoints do
				Z.ColorSequenceKeypoint.write(b, offset + 1 + (i - 1) * 4, point)
			end
			return offset + 1 + count * 4
		end,
	}
end

if DateTime then
	Z.DateTime = {
		read = function(b: buffer, offset: number): (DateTime, number)
			return DateTime.fromUnixTimestampMillis(buffer.readf64(b, offset)), offset + 8
		end,
		write = function(b: buffer, offset: number, value: DateTime): number
			buffer.writef64(b, offset, value.UnixTimestampMillis)
			return offset + 8
		end,
	}
end

if Enum then
	local enumCache = {}
	Z.EnumItem = setmetatable({
		read = function(b: buffer, offset: number): (EnumItem, number)
			local enumType, nextOffset = Z.str8.read(b, offset)
			return (Z.EnumItem :: any)(Enum[enumType]).read(b, nextOffset)
		end,
		write = function(b: buffer, offset: number, value: EnumItem): number
			offset = Z.str8.write(b, offset, tostring(value.EnumType))
			return (Z.EnumItem :: any)(value.EnumType).write(b, offset, value)
		end,
	}, {
		__call = function(_, enum: Enum): ZType
			if not enumCache[enum] then
				local items = enum:GetEnumItems()

				table.sort(items, function(a: EnumItem, b: EnumItem)
					return a.Value < b.Value
				end)

				local idToItem, itemToId = table.create(#items) :: { EnumItem }, {}
				for i, item in items do
					idToItem[i] = item
					itemToId[item] = i
				end

				local size, read, write = 4, buffer.readu32, buffer.writeu32
				local n = #items
				if n <= SIZE_8 then
					size, read, write = 1, buffer.readu8, buffer.writeu8
				elseif n <= SIZE_16 then
					size, read, write = 2, buffer.readu16, buffer.writeu16
				end

				enumCache[enum] = table.freeze({
					name = tostring(enum),
					deserialize = deserializeZType,
					read = function(b: buffer, offset: number): (EnumItem, number)
						return idToItem[read(b, offset)], offset + size
					end,
					write = function(b: buffer, offset: number, value: EnumItem): number
						write(b, offset, itemToId[value])
						return offset + size
					end,
				})
			end

			return enumCache[enum] :: any
		end,
	})
end

if Faces then
	Z.Faces = {
		read = function(b: buffer, offset: number): (Faces, number)
			local back, bottom, front, left, right, top = readBool(b, offset)
			return Faces.new(
				back and Enum.NormalId.Back :: any,
				bottom and Enum.NormalId.Bottom :: any,
				front and Enum.NormalId.Front :: any,
				left and Enum.NormalId.Left :: any,
				right and Enum.NormalId.Right :: any,
				top and Enum.NormalId.Top :: any
			),
				offset + 1
		end,
		write = function(b: buffer, offset: number, value: Faces): number
			writeBool(b, offset, value.Back, value.Bottom, value.Front, value.Left, value.Right, value.Top)
			return offset + 1
		end,
	}
end

if FloatCurveKey then
	Z.FloatCurveKey = {
		read = function(b: buffer, offset: number): (FloatCurveKey, number)
			local interpolation = Z.EnumItem(Enum.KeyInterpolationMode).read(b, offset)
			local time = buffer.readf32(b, offset + 1)
			local value = buffer.readf32(b, offset + 5)
			local result = FloatCurveKey.new(time, value, interpolation)
			offset += 9
			if interpolation == Enum.KeyInterpolationMode.Cubic then
				result.LeftTangent, offset = Z.some(Z.f32).read(b, offset)
				result.RightTangent, offset = Z.some(Z.f32).read(b, offset)
			end
			return result, offset
		end,
		write = function(b: buffer, offset: number, value: FloatCurveKey): number
			Z.EnumItem(Enum.KeyInterpolationMode).write(b, offset, value.Interpolation)
			buffer.writef32(b, offset + 1, value.Time)
			buffer.writef32(b, offset + 5, value.Value)
			offset += 9
			if value.Interpolation == Enum.KeyInterpolationMode.Cubic then
				offset = Z.some(Z.f32).write(b, offset, value.LeftTangent)
				offset = Z.some(Z.f32).write(b, offset, value.RightTangent)
			end
			return offset
		end,
	}
end

if Font then
	local weights = Enum.FontWeight:GetEnumItems()
	table.sort(weights, function(a: EnumItem, b: EnumItem)
		return a.Value < b.Value
	end)

	local idToWeight, weightToId = table.create(#weights) :: { Enum.FontWeight }, {}
	for i, v in weights do
		idToWeight[i] = v
		weightToId[v] = i
	end

	Z.Font = {
		read = function(b: buffer, offset: number): (Font, number)
			local byte = buffer.readu8(b, offset)
			local family, newOffset = Z.str8.read(b, offset + 1)
			local font = Font.new(
				family,
				idToWeight[byte // 4],
				if byte % 4 >= 2 then Enum.FontStyle.Italic else Enum.FontStyle.Normal
			)
			if byte % 2 == 1 then
				font.Bold = true
			end
			return font, newOffset
		end,
		write = function(b: buffer, offset: number, value: Font): number
			local byte = if value.Bold then 1 else 0
			if value.Style == Enum.FontStyle.Italic then
				byte += 2
			end
			byte += weightToId[value.Weight] * 4
			buffer.writeu8(b, offset, byte)
			return Z.str8.write(b, offset + 1, value.Family)
		end,
	}
end

if NumberRange then
	Z.NumberRange = {
		read = function(b: buffer, offset: number): (NumberRange, number)
			local min = buffer.readf64(b, offset)
			local max = buffer.readf64(b, offset + 8)
			return NumberRange.new(min, max), offset + 16
		end,
		write = function(b: buffer, offset: number, value: NumberRange): number
			buffer.writef64(b, offset, value.Min)
			buffer.writef64(b, offset + 8, value.Max)
			return offset + 16
		end,
	}
end

if NumberSequenceKeypoint then
	Z.NumberSequenceKeypoint = {
		read = function(b: buffer, offset: number): (NumberSequenceKeypoint, number)
			return NumberSequenceKeypoint.new(
				buffer.readf32(b, offset),
				buffer.readf32(b, offset + 4),
				buffer.readf32(b, offset + 8)
			),
				offset + 12
		end,
		write = function(b: buffer, offset: number, value: NumberSequenceKeypoint): number
			buffer.writef32(b, offset, value.Time)
			buffer.writef32(b, offset + 4, value.Value)
			buffer.writef32(b, offset + 8, value.Envelope)
			return offset + 12
		end,
	}
end

if NumberSequence then
	Z.NumberSequence = {
		read = function(b: buffer, offset: number): (NumberSequence, number)
			local count = buffer.readu8(b, offset)
			local keypoints: { NumberSequenceKeypoint } = {}
			for i = 1, count do
				keypoints[i] = Z.NumberSequenceKeypoint.read(b, offset + 1 + (i - 1) * 12)
			end
			return NumberSequence.new(keypoints), offset + 1 + count * 12
		end,
		write = function(b: buffer, offset: number, value: NumberSequence): number
			local count = #value.Keypoints
			buffer.writeu8(b, offset, count)
			for i, point in value.Keypoints do
				Z.NumberSequenceKeypoint.write(b, offset + 1 + (i - 1) * 12, point)
			end
			return offset + 1 + count * 12
		end,
	}
end

if UDim then
	Z.UDim = {
		read = function(b: buffer, offset: number): (UDim, number)
			return UDim.new(buffer.readf32(b, offset), buffer.readf32(b, offset + 4)), offset + 8
		end,
		write = function(b: buffer, offset: number, value: UDim): number
			buffer.writef32(b, offset, value.Scale)
			buffer.writef32(b, offset + 4, value.Offset)
			return offset + 8
		end,
	}
end

if UDim2 then
	Z.UDim2 = {
		read = function(b: buffer, offset: number): (UDim2, number)
			return UDim2.new(
				buffer.readf32(b, offset),
				buffer.readf32(b, offset + 4),
				buffer.readf32(b, offset + 8),
				buffer.readf32(b, offset + 12)
			),
				offset + 16
		end,
		write = function(b: buffer, offset: number, value: UDim2): number
			buffer.writef32(b, offset, value.X.Scale)
			buffer.writef32(b, offset + 4, value.X.Offset)
			buffer.writef32(b, offset + 8, value.Y.Scale)
			buffer.writef32(b, offset + 12, value.Y.Offset)
			return offset + 16
		end,
	}
end

if Vector2 then
	Z.Vector2 = {
		read = function(b: buffer, offset: number): (Vector2, number)
			return Vector2.new(buffer.readf32(b, offset), buffer.readf32(b, offset + 4)), offset + 8
		end,
		write = function(b: buffer, offset: number, value: Vector2): number
			buffer.writef32(b, offset, value.X)
			buffer.writef32(b, offset + 4, value.Y)
			return offset + 8
		end,
	}
end

if Vector2int16 then
	Z.Vector2i16 = {
		read = function(b: buffer, offset: number): (Vector2int16, number)
			return Vector2int16.new(buffer.readi16(b, offset), buffer.readi16(b, offset + 2)), offset + 4
		end,
		write = function(b: buffer, offset: number, value: Vector2int16): number
			buffer.writei16(b, offset, value.X)
			buffer.writei16(b, offset + 2, value.Y)
			return offset + 4
		end,
	}
	Z.Vector2int16 = Z.Vector2i16
end

if Vector3 then
	Z.Vector3 = {
		read = function(b: buffer, offset: number): (Vector3, number)
			return Vector3.new(buffer.readf32(b, offset), buffer.readf32(b, offset + 4), buffer.readf32(b, offset + 8)),
				offset + 12
		end,
		write = function(b: buffer, offset: number, value: Vector3): number
			buffer.writef32(b, offset, value.X)
			buffer.writef32(b, offset + 4, value.Y)
			buffer.writef32(b, offset + 8, value.Z)
			return offset + 12
		end,
	}
end

if Vector3int16 then
	Z.Vector3i16 = {
		read = function(b: buffer, offset: number): (Vector3int16, number)
			return Vector3int16.new(
				buffer.readi16(b, offset),
				buffer.readi16(b, offset + 2),
				buffer.readi16(b, offset + 4)
			),
				offset + 6
		end,
		write = function(b: buffer, offset: number, value: Vector3int16): number
			buffer.writei16(b, offset, value.X)
			buffer.writei16(b, offset + 2, value.Y)
			buffer.writei16(b, offset + 4, value.Z)
			return offset + 6
		end,
	}
	Z.Vector3int16 = Z.Vector3i16
end

if Path2DControlPoint then
	local ZERO = UDim2.new()
	Z.Path2DControlPoint = {
		read = function(b: buffer, offset: number): (Path2DControlPoint, number)
			local position, leftTangentOffset = Z.some(Z.UDim2).read(b, offset)
			local leftTangent, rightTangentOffset = Z.some(Z.UDim2).read(b, leftTangentOffset)
			local rightTangent, nextOffset = Z.some(Z.UDim2).read(b, rightTangentOffset)
			return Path2DControlPoint.new(position or ZERO, leftTangent or ZERO, rightTangent or ZERO), nextOffset
		end,
		write = function(b: buffer, offset: number, v: Path2DControlPoint): number
			offset = Z.some(Z.UDim2).write(b, offset, if v.Position ~= ZERO then v.Position else nil)
			offset = Z.some(Z.UDim2).write(b, offset, if v.LeftTangent ~= ZERO then v.LeftTangent else nil)
			return Z.some(Z.UDim2).write(b, offset, if v.RightTangent ~= ZERO then v.RightTangent else nil)
		end,
	}
end

if PathWaypoint then
	Z.PathWaypoint = {
		read = function(b: buffer, offset: number): (PathWaypoint, number)
			local label, newOffset = Z.str8.read(b, offset + 13)
			return PathWaypoint.new(
				Z.Vector3.read(b, offset + 1),
				Enum.PathWaypointAction:FromValue(buffer.readu8(b, offset)) or Enum.PathWaypointAction.Walk,
				label
			),
				newOffset
		end,
		write = function(b: buffer, offset: number, value: PathWaypoint): number
			buffer.writeu8(b, offset, value.Action.Value)
			return Z.str8.write(b, Z.Vector3.write(b, offset + 1, value.Position), value.Label)
		end,
	}
end

if PhysicalProperties then
	Z.PhysicalProperties = {
		read = function(b: buffer, offset: number): (PhysicalProperties, number)
			return PhysicalProperties.new(
				buffer.readf32(b, offset),
				buffer.readf32(b, offset + 4),
				buffer.readf32(b, offset + 8),
				buffer.readf32(b, offset + 12),
				buffer.readf32(b, offset + 16)
			),
				offset + 20
		end,
		write = function(b: buffer, offset: number, value: PhysicalProperties): number
			buffer.writef32(b, offset, value.Density)
			buffer.writef32(b, offset + 4, value.Friction)
			buffer.writef32(b, offset + 8, value.Elasticity)
			buffer.writef32(b, offset + 12, value.FrictionWeight)
			buffer.writef32(b, offset + 16, value.ElasticityWeight)
			return offset + 20
		end,
	}
end

if Ray then
	Z.Ray = {
		read = function(b: buffer, offset: number): (Ray, number)
			local origin = Z.Vector3.read(b, offset)
			local direction = Z.Vector3.read(b, offset + 12)
			return Ray.new(origin, direction), offset + 24
		end,
		write = function(b: buffer, offset: number, value: Ray): number
			return Z.Vector3.write(b, Z.Vector3.write(b, offset, value.Origin), value.Direction)
		end,
	}
end

if Rect then
	Z.Rect = {
		read = function(b: buffer, offset: number): (Rect, number)
			local min = Z.Vector2.read(b, offset)
			local max = Z.Vector2.read(b, offset + 8)
			return Rect.new(min, max), offset + 16
		end,
		write = function(b: buffer, offset: number, value: Rect): number
			return Z.Vector2.write(b, Z.Vector2.write(b, offset, value.Min), value.Max)
		end,
	}
end

if Region3 then
	Z.Region3 = {
		read = function(b: buffer, offset: number): (Region3, number)
			local min = Z.Vector3.read(b, offset)
			local max = Z.Vector3.read(b, offset + 12)
			return Region3.new(min, max), offset + 24
		end,
		write = function(b: buffer, offset: number, value: Region3): number
			local halfSize = value.Size / 2
			local pos = value.CFrame.Position
			return Z.Vector3.write(b, Z.Vector3.write(b, offset, pos - halfSize), pos + halfSize)
		end,
	}
end

if Region3int16 then
	Z.Region3int16 = {
		read = function(b: buffer, offset: number): (Region3int16, number)
			local min = Z.Vector3i16.read(b, offset)
			local max = Z.Vector3i16.read(b, offset + 6)
			return Region3int16.new(min, max), offset + 12
		end,
		write = function(b: buffer, offset: number, value: Region3int16): number
			return Z.Vector3i16.write(b, Z.Vector3i16.write(b, offset, value.Min), value.Max)
		end,
	}
end

if RotationCurveKey then
	Z.RotationCurveKey = {
		read = function(b: buffer, offset: number): (RotationCurveKey, number)
			local interpolation = Z.EnumItem(Enum.KeyInterpolationMode).read(b, offset)
			local time = buffer.readf32(b, offset + 1)
			local value = Z.CFrame.read(b, offset + 5)
			local result = RotationCurveKey.new(time, value, interpolation)
			offset += 53
			if interpolation == Enum.KeyInterpolationMode.Cubic then
				result.LeftTangent, offset = Z.some(Z.f32).read(b, offset)
				result.RightTangent, offset = Z.some(Z.f32).read(b, offset)
			end
			return result, offset
		end,
		write = function(b: buffer, offset: number, value: RotationCurveKey): number
			Z.EnumItem(Enum.KeyInterpolationMode).write(b, offset, value.Interpolation)
			buffer.writef32(b, offset + 1, value.Time)
			offset = Z.CFrame.write(b, offset + 5, value.Value)
			if value.Interpolation == Enum.KeyInterpolationMode.Cubic then
				offset = Z.some(Z.f32).write(b, offset, value.LeftTangent)
				return Z.some(Z.f32).write(b, offset, value.RightTangent)
			end
			return offset
		end,
	}
end

if TweenInfo then
	local direction = Z.EnumItem(Enum.EasingDirection)
	local style = Z.EnumItem(Enum.EasingStyle)
	Z.TweenInfo = {
		read = function(b: buffer, offset: number): (TweenInfo, number)
			local result = TweenInfo.new(
				buffer.readf32(b, offset),
				style.read(b, offset + 11),
				direction.read(b, offset + 12),
				buffer.readi16(b, offset + 8),
				buffer.readu8(b, offset + 10) == 255,
				buffer.readf32(b, offset + 4)
			)
			return result, offset + 13
		end,
		write = function(b: buffer, offset: number, value: TweenInfo): number
			buffer.writef32(b, offset, value.Time)
			buffer.writef32(b, offset + 4, value.DelayTime)
			buffer.writei16(b, offset + 8, value.RepeatCount)
			buffer.writeu8(b, offset + 10, if value.Reverses then 255 else 0)
			return direction.write(b, style.write(b, offset + 11, value.EasingStyle), value.EasingDirection)
		end,
	}
end

local idToZType, ZTypeToId = { Z.EnumItem :: any } :: { ZType }, {} :: { [ZType]: number }

Z.table = {
	read = function(b: buffer, offset: number): ({ [any]: any }, number)
		local length = buffer.readu32(b, offset)
		local value = table.create(length)
		offset += 4
		for _ = 1, length do
			local zTypeK = idToZType[buffer.readu8(b, offset)]
			local zTypeV = idToZType[buffer.readu8(b, offset + 1)]
			local k, valueOffset = zTypeK.read(b, offset + 2)
			local v, nextOffset = zTypeV.read(b, valueOffset)
			offset = nextOffset
			value[k] = v
		end
		return value, offset
	end,
	write = function(b: buffer, offset: number, value: { [any]: any }): number
		local length = 0
		local start = offset
		offset += 4
		for k, v in value do
			local typeK = typeof(k)
			local zTypeK: ZType = Z[typeK :: any]
			if not zTypeK then
				error(`unsupported type "{typeK}" for key "{k}"`)
			end
			local typeV = typeof(v)
			local zTypeV: ZType = Z[typeV :: any]
			if not zTypeV then
				error(`unsupported type "{typeV}" for value "{tostring(v)}" of key "{k}"`)
			end
			buffer.writeu16(b, offset, ZTypeToId[zTypeK] + ZTypeToId[zTypeV] * 2 ^ 8)
			offset = zTypeK.write(b, offset + 2, k)
			offset = zTypeV.write(b, offset, v)
			length += 1
		end
		buffer.writeu32(b, start, length)
		return offset
	end,
}

for k, v in next, Z do
	if isZType(v) and not table.find(idToZType, v :: ZType) then
		table.insert(idToZType, v :: ZType)
	end
end

table.sort(idToZType, function(a: any, b: any)
	return a.name < b.name
end)

for i, v in idToZType do
	ZTypeToId[v] = i
end

local function serializeUnsafe(schema: Schema, obj: Data, b: buffer?, offset: number?): number
	b = b or BUFFER
	offset = offset or 0

	for _, field in schema.fields do
		offset = field.write(b :: buffer, offset :: number, obj[field.key])
	end

	return offset :: number
end

local function serializeListUnsafe(schema: Schema, list: { any }, b: buffer?, offset: number?): number
	b = b or BUFFER
	offset = (offset or 0) + schema.sizeLen

	if #list > 2 ^ (schema.sizeLen * 8) - 1 then
		error(`List length exceeds bounds of {2 ^ (schema.sizeLen * 8) - 1}, got {#list}`)
	end

	schema.writeLen(b :: buffer, offset :: number - schema.sizeLen, #list)

	local write = schema.fields[1].write

	for _, obj in list do
		offset = write(b :: buffer, offset :: number, obj)
	end

	return offset :: number
end

local function serializeMapUnsafe(schema: Schema, map: { [any]: any }, b: buffer?, offset: number?): number
	b = b or BUFFER
	offset = (offset or 0) + schema.sizeLen

	local start = offset :: number - schema.sizeLen
	local writeK = (schema.fields[1].key :: ZType).write
	local writeV = schema.fields[1].write

	local n = 0
	for k, v in map do
		offset = writeK(b :: buffer, offset :: number, k)
		offset = writeV(b :: buffer, offset :: number, v)
		n += 1
	end

	if n > 2 ^ (schema.sizeLen * 8) - 1 then
		error(`Map length exceeds bounds of {2 ^ (schema.sizeLen * 8) - 1}, got {n}`)
	end

	schema.writeLen(b :: buffer, start, n)

	return offset :: number
end

local function deserialize(schema: Schema, b: buffer, offset: number?, safe: boolean?): (Data, number)
	local cursor = offset or 0
	local result: Data

	if safe then
		result = {} :: Data
		for _, field in schema.fields do
			local ok, value, pos = pcall(field.read :: any, b, cursor, safe)
			if ok then
				result[field.key], cursor = value, pos
			end
		end
	else
		result = {} :: Data
		for _, field in schema.fields do
			result[field.key], cursor = field.read(b, cursor)
		end
	end

	return result, cursor
end

local function deserializeList(schema: Schema, b: buffer, offset: number?, safe: boolean?): (Data, number)
	local cursor = offset or 0
	local read = schema.fields[1].read
	local result: Data

	if safe then
		local ok, length = pcall(schema.readLen :: any, b, cursor)
		if not ok then
			return result, cursor
		end
		result = table.create(length) :: Data
		cursor += schema.sizeLen
		for i = 1, length do
			local success, value, pos = pcall(read :: any, b, cursor, safe)
			if not success then
				break
			end
			result[i], cursor = value, pos
		end
	else
		local length = schema.readLen(b, cursor)
		cursor += schema.sizeLen
		result = table.create(length) :: Data
		for i = 1, length do
			result[i], cursor = read(b, cursor)
		end
	end

	return result, cursor
end

local function deserializeMap(schema: Schema, b: buffer, offset: number?, safe: boolean?): (Data, number)
	local cursor = offset or 0
	local readK = (schema.fields[1].key :: ZType).read
	local readV = schema.fields[1].read
	local result: Data

	if safe then
		local ok, length = pcall(schema.readLen :: any, b, cursor)
		if not ok then
			return result, cursor
		end
		result = table.create(length) :: Data
		cursor += schema.sizeLen
		for i = 1, length do
			local success, key, pos = pcall(readK :: any, b, cursor, safe)
			if not success then
				break
			end
			local value
			success, value, pos = pcall(readV :: any, b, pos, safe)
			if not success then
				break
			end
			result[key], cursor = value, pos
		end
	else
		local length = schema.readLen(b, cursor)
		cursor += schema.sizeLen
		result = table.create(length) :: Data
		for i = 1, length do
			local key
			key, cursor = readK(b, cursor)
			result[key], cursor = readV(b, cursor)
		end
	end

	return result, cursor
end

--- Serializes a table. Returns a new buffer or the next write offset if a buffer is provided.
function Z.ser(schema: Schema, obj: any, b: buffer?, offset: number?, maxSize: number?): (buffer? | number?, string?)
	local shouldReturnOffset = b
	b = b or BUFFER
	offset = offset or 0

	local ok, result = pcall(schema.serializeUnsafe :: any, schema, obj, b, offset)

	if not ok then
		if isZType(schema) and schema.name ~= "Schema" then
			ok, result = pcall(schema.write, b :: buffer, offset :: number, obj)

			if not ok then
				return nil, result
			end

			if shouldReturnOffset then
				return result, nil
			elseif maxSize then
				local length = math.min(result, maxSize)
				local new = buffer.create(length)
				buffer.copy(new, 0, BUFFER, 0, length)

				return new, nil
			end

			local new = buffer.create(result)
			buffer.copy(new, 0, BUFFER, 0, result)

			return new, nil
		end

		for _, field in schema.fields do
			local value = obj[field.key]
			if value ~= nil then
				local success
				success, offset = pcall(field.write :: any, b :: buffer, offset :: number, value)
				if not success then
					local name = if isZType(field.key) then (field.key :: any).name else field.key
					return nil,
						`Failed to serialize field "{name}", expected "{field.type}", got "{typeof(value)}"); Message: {offset}`
				end
			elseif not schema.isList and not schema.isMap then
				return nil, `Missing field "{if isZType(field.key) then (field.key :: any).name else field.key}"`
			end
		end

		return nil, result :: string?
	elseif shouldReturnOffset then
		return result, nil
	elseif maxSize then
		local length = math.min(result :: number, maxSize)
		local new = buffer.create(length)
		buffer.copy(new, 0, BUFFER, 0, length)

		return new, nil
	end

	local new = buffer.create(result :: number)
	buffer.copy(new, 0, BUFFER, 0, result :: number)

	return new, nil
end

--- Deserializes a buffer into a table. The `safe` flag suppresses errors from incomplete data.
function Z.des(schema: Schema, b: buffer, offset: number?, safe: boolean?): (Data, number)
	return schema:deserialize(b, offset, safe)
end

local function sortByKey(a: Field, b: Field): boolean
	return (a.key :: string) < (b.key :: string)
end

--- Creates a schema for serialization.
function Z.schema(definition: SchemaDefinition, bits: number?): Schema
	local fields: { Field } = {}
	local isList = #definition == 1
	local firstKey = next(definition)
	local isMap = isZType(firstKey)

	local readLen, writeLen = buffer.readu32, buffer.writeu32
	if isList or isMap then
		if bits == 8 then
			readLen, writeLen = buffer.readu8, buffer.writeu8
		elseif bits == 16 then
			readLen, writeLen = buffer.readu16, buffer.writeu16
		elseif bits ~= 32 and bits ~= nil then
			error(`Expected 8, 16, or 32 for parameter "bits", got {bits}`)
		end
	end

	for key, value: ZType in next, definition do
		if isList and key ~= 1 then
			error(`Expected \{ Z.{definition[1]} } for list schema, got field "{key}"`)
		elseif isMap then
			if key ~= firstKey then
				error(
					`Expected \{ [Z.{(key :: any).name}] = Z.{(value :: any).name} } for map schema, got field "{key}"`
				)
			end
		elseif type(key) ~= "string" and type(key) ~= "number" then
			error(`Expected "string" or "number" for field "{tostring(key)}", got "{typeof(key)}"`)
		end

		if not isZType(value) then
			error(`Expected "ZType" for field "{tostring(key)}", got incompatible "{typeof(key)}"`)
		end

		table.insert(fields :: any, {
			key = key,
			read = value.read,
			write = value.write,
			type = (value :: any).name,
		})
	end

	if #fields == 0 then
		error(`Empty schema`)
	end

	table.sort(fields, sortByKey)

	local schema
	schema = table.freeze({
		fields = fields,
		isList = isList,
		isMap = isMap,
		name = "Schema",
		deserialize = if isList then deserializeList elseif isMap then deserializeMap else deserialize,
		serializeUnsafe = if isList then serializeListUnsafe elseif isMap then serializeMapUnsafe else serializeUnsafe,
		read = function(b: buffer, offset: number, safe: boolean?): (Data, number)
			return Z.des(schema :: Schema, b, offset, safe)
		end,
		write = function(b: buffer, offset: number, value: any)
			if type(value) == "buffer" then
				local len = buffer.len(value)
				buffer.copy(b, offset, value, 0, len)
				return offset + len
			end
			local result, err = Z.ser(schema :: Schema, value, b, offset)
			if not result then
				error(err)
			end
			return result :: number
		end,
		readLen = readLen,
		writeLen = writeLen,
		sizeLen = math.ceil((bits or 32) / 8),
	})

	return schema :: Schema
end

return Z
